= Working with Jumpstarter

Not only can Jumpstarter help automated hardware testing in CI pipelines, as your project grows, Jumpstarter's remote access capabilities enable your team to share limited hardware devices across geographically distributed teams in a secure, controlled, and efficient manner.

Jumpstarter manages remote access to exporters using **Leases** which provide a specific **Client** access to an **Exporter** for a specified period of time. When a lease is created, the **Jumpstarter Service** will attempt to find a matching Exporter using the specified label selectors. Once a lease is acquired, the Client can start a session within that lease to access the hardware remotely.

Your Dev Space is already configured with credentials to access a Jumpstarter Service running in the same cluster with multiple Exporters available to lease.

'''

image::app/new-terminal.png[]

First let's create a terminal window by clicking the *+* button.

image::app/new-terminal-created.png[]

You should see a new terminal like this. The following commands should be executed in this newly created terminal.

To list the available Exporters, run:

[,console]
----
$ jmp get exporters
----

Each Exporter has a set of labels, these labels can be used to select the a specific group of exporters when requesting a lease. For example, you could specify a label for the architecture and then select the correct device with an `arch=aarch64`.

[#jmpexporterlease]
== Lease and interact with a remote exporter

To lease an Exporter with the Jumpstarter CLI, run:

[,console]
----
$ jmp shell --selector type=virtual
----

NOTE: This `jmp shell` command uses the default client config file located at `~/.config/jumpstarter/clients/lab.yaml`. The default client will then use the `--selector` parameter to find an exporter that matches the label `type=virtual`.

TIP: Notice that your shell prompt have been changed to `jumpstarter ⚡remote ➤`, this is to remind you that you are inside a remote Jumpstarter shell session.

When you lease an Exporter, you get exclusive access to the hardware interfaces connected to the Exporter for the duration of the lease.

To see the list of hardware interfaces exposed on the Exporter we've leased, run the `j` command without parameters:

[,console]
----
jumpstarter ⚡remote ➤ j
----

You should see an output like this:

[source,text]
----
Usage: j [OPTIONS] COMMAND [ARGS]...

  Generic composite device

Options:
  --help  Show this message and exit.

Commands:
  console  Serial port client
  flasher  Generic flasher interface
  power    Generic power
  qemu     Generic composite device
----

As this remote exporter is connected to our virtual QEMU hardware, we can use these subcommands to interact with that virtual device. We can control the power using the `power` subcommand, flash a new image with the `flasher`, or access the serial console using `console`. A physical device using a similar interface could be interacted with in the same manner.

[TIP]
====
Notice that the same top-level commands `console`, `flasher`, and `power` are also available under the `qemu` subcommand. This is because they are aliases to the same commands under `qemu` for easier access. The `ref` field in the Exporter config allows us to define aliases to other nested drivers.

.exporter config
[source,yaml]
----
# ...
export:
  console:
    ref: qemu.console
  flasher:
    ref: qemu.flasher
  power:
    ref: qemu.power
  qemu:
    type: jumpstarter_driver_qemu.driver.Qemu
    config:
      # ...
----
====

=== First boot

Before booting our virtual device, we need to flash it with an operating system image.

[,console]
----
jumpstarter ⚡remote ➤ ./scripts/flash-prebuilt
----

NOTE: the `./scripts/flash-prebuilt` helper script flashes a prebuilt RHIVOS image to the virtual device.

After flashing, to boot the device and view the boot messages via the serial console, run:

[,console]
----
jumpstarter ⚡remote ➤ j power on && j console start-console
----

You should be dropped into a serial console with the boot messages showing up. Once the image has finished booting, you will be presented with a login prompt (`localhost login:`). You can login with the following credentials:

.Username
[source,text]
----
root
----

.Password
[source,text]
----
password
----

TIP: Notice that your shell prompt have been changed to `[root@localhost ~]#`, this is to remind you that you are inside the serial console of the virtual device.

After logging into the system, you can check the system architecture using `uname`:

[,console]
----
$ uname -m
----

It should print `aarch64` meaning that this is a arm based virtual device.

Then quit the serial console by pressing `Ctrl+B` three times.

TIP: Your shell prompt should be restored to `jumpstarter ⚡remote ➤`, this is to remind you that you are back inside a remote Jumpstarter shell session, not the serial console of the virtual device.

=== Bridging the gap

Sometimes your tests cannot be executed directly on the target device or the Exporter host. For example, you may need to use a proprietary GUI client or service to control your application. To support these use cases, Jumpstarter implements port forwarding, which allows you to interact with services running inside the target device from your local machine as if they are running locally.

To forward a remote service port such as the `ssh` to a local port, run the following command from within your remote Jumpstarter shell session:

[,console]
----
$ j qemu ssh forward-tcp 9000 &
----

This command will forward the remote `ssh` port (port 22) preconfigured in the exporter config to `localhost:9000` on your local machine. Once port forwarding is started, you can run `ssh` client from your local environment and execute commands on the virtual device remotely, e.g. listing all the files under the root directory:

[,console]
----
$ ssh -p 9000 -o StrictHostKeyChecking=no root@localhost ls /
----

When prompted for password, enter:

.Password
[source,text]
----
password
----

To stop the port forwarding, simply exit the shell with `Ctrl+D`.

Now we are finished with manual testing, exit the Jumpstarter shell session by pressing `Ctrl+D` again.

[#jmptestingpytest]
== Testing on remote exporter with Pytest

While connecting to a Jumpstarter Exporter remotely to execute our tests is already a huge step forward from the traditional ways of hardware testing, by combining the Jumpstater Python API with the pytest unit test framework, we can further improve our test process to be more automated and reliable.

TIP: You can use any testing framework with Jumpstarter, not only pytest. But we recommend pytest due to its simplicity and popularity.

An example pytest script using Jumpstarter would look like this:

.basic_test.py
[source,python]
----
from jumpstarter_testing import JumpstarterTest
from subprocess import run
import pytest
import time

class TestRHIVOS(JumpstarterTest):
    @pytest.fixture(autouse=True, scope="class")
    def prepare(self, client):
        client.power.off()
        run(["./scripts/flash-prebuilt"])
        client.power.on()
        time.sleep(10)

    def test_kernel_version(self, client):
        with client.qemu.shell() as shell:
          assert shell.run("uname -r").stdout.strip().startswith("5.14.0")

    def test_kernel_architecture(self, client):
        with client.qemu.shell() as shell:
          assert shell.run("uname -m").stdout.strip() == "aarch64"
----

Let's explore the script line by line.

.import
[source,python]
----
from jumpstarter_testing import JumpstarterTest
from subprocess import run
import pytest
import time
----

The first part are the import statements, saying that we would be using the `JumpstarterTest` helper from the `jumpstarter_testing` package, `run` function from the `subprocess` package, as well as the `pytest` and `time` package.

.setup
[source,python]
----
class TestRHIVOS(JumpstarterTest):
    @pytest.fixture(autouse=True, scope="class")
    def prepare(self, client):
        client.power.off()
        run(["./scripts/flash-prebuilt"])
        client.power.on()
        time.sleep(10)
----

The second part is how we set up the device under test for the remainder of the tests. So we base our test `TestRHIVOS` on the `JumpstarterTest` helper class, which provides the required logics for connecting to our Exporter. Then we have a `prepare` fixture that is auto used, which means it would be automatically executed before the test cases, and class scoped, which means it would only be executed once per test class, since we don't have to reflash our device under test in-between test cases.

TIP: In testing, a fixture provides a defined, reliable and consistent context for the tests. This could include environment (for example a database configured with known parameters) or content (such as a dataset), and in our case, a device with a given disk image flashed and booted up.

.cases
[source,python]
----
    def test_kernel_version(self, client):
        with client.qemu.shell() as shell:
          assert shell.run("uname -r").stdout.strip().startswith("5.14.0")

    def test_kernel_architecture(self, client):
        with client.qemu.shell() as shell:
          assert shell.run("uname -m").stdout.strip() == "aarch64"
----

And finally, the test cases, here we only have two test cases, one is `test_kernel_version`, which executes the `uname` command and checks if the kernel version matches our desired version of `5.14.0`, another is `test_kernel_architecture`, which checks if the virtual device is indeed of arm architecture.

To lease another Exporter and execute our test cased on it, run:

[,console]
----
$ jmp shell --selector type=virtual -- pytest basic_test.py
----
