= Working with Jumpstarter

Not only can Jumpstarter help automated hardware testing in CI pipelines, as your project grows, Jumpstarter's remote access capabilities enable your team to share limited hardware devices across geographically distributed teams in a secure, controlled, and efficient manner.

Jumpstarter manages remote access to exporters using **Leases** which provide a specific **Client** access to an **Exporter** for a specified period of time. When a lease is created, the **Jumpstarter Service** will attempt to find a matching Exporter using the specified label selectors. Once a lease is acquired, the Client can start a session within that lease to access the hardware remotely.

Your Dev Space is already configured with credentials to access a Jumpstarter Service running in the same cluster with multiple Exporters available to lease.

== List the Exporters

IMPORTANT: First let's create a terminal window by clicking the *+* button.

image::app/new-terminal.png[]

You should see a new terminal like this. The following commands should be executed in this newly created terminal.

image::app/new-terminal-created.png[]

To list the available Exporters, run:

[source,sh,role=execute]
----
jmp get exporters
----

Each Exporter has a set of labels, these labels can be used to select the a specific group of exporters when requesting a lease. For example, you could specify a label for the architecture and then select the correct device with an `arch=aarch64`.

[#jmpexporterlease]
== Leases and remote Exporters

To lease an Exporter with the Jumpstarter CLI, run:

[source,sh,role=execute]
----
jmp shell --selector type=virtual
----

NOTE: This `jmp shell` command uses the default client config file located at `~/.config/jumpstarter/clients/lab.yaml`. The default client will then use the `--selector` parameter to find an exporter that matches the label `type=virtual`.

TIP: Notice that your shell prompt have been changed to `jumpstarter ⚡remote ➤`, this is to remind you that you are inside a remote Jumpstarter shell session.

When you lease an Exporter, you get exclusive access to the hardware interfaces connected to the Exporter for the duration of the lease.

To see the list of hardware interfaces exposed on the Exporter we've leased, run the `j` command without parameters:

[source,sh,role=execute]
----
j
----

You should see an output like this:

[source,sh]
----
Usage: j [OPTIONS] COMMAND [ARGS]...

  Generic composite device

Options:
  --help  Show this message and exit.

Commands:
  console  Serial port client
  flasher  Generic flasher interface
  power    Generic power
  qemu     Generic composite device
----

As this remote exporter is connected to our virtual QEMU hardware, we can use these subcommands to interact with that virtual device. We can control the power using the `power` subcommand, flash a new image with the `flasher`, or access the serial console using `console`. A physical device using a similar interface could be interacted with in the same manner.

[TIP]
====
Notice that the same top-level commands `console`, `flasher`, and `power` are also available under the `qemu` subcommand. This is because they are aliases to the same commands under `qemu` for easier access. The `ref` field in the Exporter config allows us to define aliases to other nested drivers.

.exporter config
[source,yaml]
----
# ...
export:
  console:
    ref: qemu.console
  flasher:
    ref: qemu.flasher
  power:
    ref: qemu.power
  qemu:
    type: jumpstarter_driver_qemu.driver.Qemu
    config:
      # ...
----
====

=== First boot

Before booting our virtual device, we need to flash it with an operating system image.

[source,sh,role=execute]
----
./scripts/flash-prebuilt
----

NOTE: the `./scripts/flash-prebuilt` script flashes a prebuilt RHIVOS image to the virtual device. We will build a custom image in a later exercise.

After flashing, to boot the device and view the boot messages via the serial console, run:

[source,sh,role=execute]
----
j power on && j console start-console
----

You should be dropped into a serial console with the boot messages showing up. Once the image has finished booting, you will be presented with a login prompt (`localhost login:`). You can login with the following credentials:

.Username
[.no-copy-label]
[source,text,role=execute,subs=attributes+]
----
root
----

.Password
[.no-copy-label]
[source,text,role=execute,subs=attributes+]
----
password
----

TIP: Notice that your shell prompt have been changed to `[root@localhost ~]#`, this is to remind you that you are inside the serial console of the virtual device.

After logging into the system, you can check the system architecture using `uname`:

[source,sh,role=execute]
----
uname -m
----

It should print `aarch64` meaning that this is a arm based virtual device.

Then quit the serial console by *pressing `Ctrl+B` three times*.

TIP: Your shell prompt should be restored to `jumpstarter ⚡remote ➤`, this is to remind you that you are back inside a remote Jumpstarter shell session, not the serial console of the virtual device.


=== Port forwarding and remote acccess

Sometimes your tests cannot be executed directly on the target device or the Exporter host.

For example, you may need to use a proprietary GUI client or service to control your application. To support these use cases, Jumpstarter implements port forwarding, which allows you to interact with services running inside the target device from your local machine as if they are running locally.

To forward a remote service port such as the `ssh` to a local port, run the following command from within your remote Jumpstarter shell session:

[source,sh,role=execute]
----
j qemu ssh forward-tcp 9000 &
----

This command will forward the remote `ssh` port (port 22) preconfigured in the exporter config to `localhost:9000` on your local machine. Once port forwarding is started, you can run `ssh` client from your local environment and execute commands on the virtual device remotely, e.g. check cpu info:

[source,sh,role=execute]
----
ssh -p 9000 -o StrictHostKeyChecking=no  \
            -o UserKnownHostsFile=/dev/null \
            root@localhost cat /proc/cpuinfo
----

When prompted for password, enter:

.Password
[.no-copy-label]
[source,text,role=execute,subs=attributes+]
----
password
----

[#jmptestingpytest]
== Testing with Pytest

While connecting to a Jumpstarter Exporter remotely to execute our tests is already a huge step forward from the traditional ways of hardware testing, by combining the Jumpstater Python API with the pytest unit test framework, we can further improve our test process to be more automated and reliable.

TIP: You can use any testing framework with Jumpstarter, not only pytest. But we recommend pytest due to its simplicity and popularity.

=== Writing tests

An example pytest script using Jumpstarter would look like this:

.test/test_on_hardware.py
[source,python]
----
import logging
import sys

import pytest

from jumpstarter_testing.pytest import JumpstarterTest


log = logging.getLogger(__name__)


class TestRHIVOSOnHardware(JumpstarterTest):
    selector = "type=virtual"

    def test_boot(self, client):
        """Test the boot process of the device."""
        log.info("Testing boot process")
        client.power.cycle()
        with client.console.pexpect() as console:
            # uncomment this if you want to see the console in action while testing
            # console.logfile_read = sys.stdout.buffer
            console.expect_exact("login:", timeout=120)
            console.sendline("root")
            console.expect_exact("Password:", timeout=10)
            console.sendline("password")
            console.expect_exact("]#", timeout=10)
    def test_uname(self, client):
        with client.console.pexpect() as console:
            console.sendline("uname -a")
            console.expect_exact("]#", timeout=10)
            print(console.before.decode())
----

Let's explore the script line by line.

.import
[source,python]
----
import logging
import sys

import pytest

from jumpstarter_testing.pytest import JumpstarterTest
----

The first part are the import statements, saying that we would be using the
`JumpstarterTest` helper from the `jumpstarter_testing` packages, as well as
`pytest`, `sys` and `logging` packages.

.setup
[source,python]
----
class TestRHIVOSOnHardware(JumpstarterTest):
    selector = "type=virtual"
----

The second part is the setup of our test class, we define a class `TestRHIVOSOnHardware`
that inherits from `JumpstarterTest`, which provides us with the required logics for
connecting to our Exporter. 

We also define a `selector` class variable, which is used to select the Exporter we want to lease by default.
In this case, we are selecting the `type=virtual`, if we are running pytest under a jumpstarter
shell this will be ignored.

.test-boot
[source,python]
----
    def test_boot(self, client):
        """Test the boot process of the device."""
        log.info("Testing boot process")
        client.power.cycle()
        with client.console.pexpect() as console:
            # uncomment this if you want to see the console in action while testing
            # console.logfile_read = sys.stdout.buffer
            console.expect_exact("login:", timeout=120)
            console.sendline("root")
            console.expect_exact("Password:", timeout=10)
            console.sendline("password")
            console.expect_exact("]#", timeout=10)
----

This is the first test case, `test_boot`, which tests the boot process of the device,
it first cycles the power of the device, then it connects to the console and waits for
the login prompt, then sends the username and password to login to the device.

After logging in, it waits for the shell prompt to show up, indicating that the login
was successful.

.test-uname
[source,python]
----
    def test_uname(self, client):
        with client.console.pexpect() as console:
            console.sendline("uname -a")
            console.expect_exact("]#", timeout=10)
            print(console.before.decode())
----

The second test case `test_uname` sends the `uname -a` command to the console and
waits for the shell prompt to show up, then prints the output of the command.

=== Running tests

Now let's run the test script using pytest to see it in action. The test scripts are
located in the `tests` directory of the project.

image::act4/test-sources.png[]

We should still be inside the remote Jumpstarter shell session from the previous steps:
[,console]
----
jumpstarter ⚡remote ➤
----

TIP: If you are not inside the remote Jumpstarter shell session, you should run `jmp shell --selector type=virtual` to lease a new Exporter. and then run the `./scripts/flash-prebuilt` command to flash the image again.

You can simply run the test script using pytest:
[source,sh,role=execute]
----
pytest
----

You should see the test results like this:

[,console]
----
jumpstarter-lab ⚡remote ➤ pytest
========================================================================= test session starts =========================================================================
platform linux -- Python 3.12.9, pytest-8.3.5, pluggy-1.5.0
rootdir: /projects/jumpstarter-lab
configfile: pytest.ini
plugins: anyio-4.9.0, asyncio-0.26.0, cov-6.1.1
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
collected 5 items

tests/test_on_hardware.py::TestRHIVOSOnHardware::test_boot
---------------------------------------------------------------------------- live log call ----------------------------------------------------------------------------
INFO     test_on_hardware:test_on_hardware.py:17 Testing boot process
INFO     PowerClient:client.py:19 Starting power cycle sequence
INFO     PowerClient:client.py:21 Waiting 2 seconds...
INFO     PowerClient:client.py:24 Power cycle sequence complete
PASSED
tests/test_on_hardware.py::TestRHIVOSOnHardware::test_uname uname -a
Linux demo 5.14.0-578.527.el9iv.aarch64 #1 SMP PREEMPT_RT Thu Apr 10 15:56:34 UTC 2025 aarch64 aarch64 aarch64 GNU/Linux
[root@demo ~
PASSED
tests/test_on_hardware.py::TestRHIVOSOnHardware::test_podman_images SKIPPED (will test this once we build our app)
tests/test_on_hardware.py::TestRHIVOSOnHardware::test_radio_service SKIPPED (will test this once we build our app)
tests/test_on_hardware.py::TestRHIVOSOnHardware::test_radio_service_interaction SKIPPED (will test this once we build our app)

==================================================================== 2 passed, 3 skipped in 18.82s ====================================================================
----

NOTE: You will notice that some of the tests are skipped, this is because we haven't built our application yet. We will come back to this later.
