= Testing and Validation

== Overview

While Red Hat OpenShift Dev Spaces provides a consistent environment for developing, building, and testing automotive applications, comprehensive validation 
requires testing on virtual or physical hardware. 

This additional testing ensures:

- System stability
- Allows for performance optimization
- Compatibility across target platforms

Before building a production-ready RHIVOS image, we must verify our application functions correctly in a cloud environment. 

After that, we will build a RHIVOS image with our modified application embedded, preparing it for end-to-end testing in
virtualized hardware environments using Jumpstarter.

NOTE: This activity builds upon our previous work, where we modified the application code.

[#test-app]
== Enable tests of the app

Before publishing our changes to the app, we need to enable the tests of the app.

image::app/14-enable-test.png[]

IMPORTANT: Open `tests/test_on_hardware.py` from the file explorer, and remove the three annotated lines.

image::app/14-enable-test-done.png[]

IMPORTANT: The lines should look like this when done.

[source,python]
----
    def test_podman_images(self, client):
        with client.console.pexpect() as console:
            console.sendline("podman images")
            console.expect_exact("]#", timeout=10)
            assert "localhost/app" in console.before.decode()
----

The first test is to check if the container image of the apps is present.

[source,python]
----
    def test_radio_service(self, client):
        with client.console.pexpect() as console:
            console.sendline("systemctl status --no-pager radio.service")
            console.expect_exact("]#", timeout=10)
----

The second test is to check if the radio app is running as a system service.

[source,python]
----
    def test_radio_service_interaction(self, client):
        with client.console.pexpect() as console:
            console.sendline("podman exec -i systemd-radio radio-client")
            console.expect_exact("Connecting to radio service", timeout=10)

            # test changing volume
            console.sendline("+" * 10)
            console.expect_exact("Volume:  [#####################]", timeout=10)
            console.sendline("-" * 10)
            console.expect_exact("Volume:  [                     ]", timeout=10)
            console.sendline("+" * 5)
            console.expect_exact("Volume:  [##########           ]", timeout=10)

            console.sendline("q")
            console.expect_exact("]#", timeout=10)
----

The third test is to interact with the radio service, and see if we can change volume.

[#container]
== Container image build

In order to build the container image, we will create a *pull request* against the `main` branch.

image::app/14-branch.png[]

IMPORTANT: Bring up the branch selector by clicking the button saying `main` at the bottom left of the screen.

image::app/15-branch-create.png[]

IMPORTANT: In the input box, put `develop`, then click *Create new branch*.

image::app/16-branch-created.png[]

TIP: Make sure the button on the bottom left of the screen now says `develop`, the name of the newly created branch, 
then click the annotated button on the left to open the source control tab.

image::app/17-commit.png[]

IMPORTANT: In the input box, put `"add new radio station"` as the commit message, then click *Commit*.

image::app/18-push.png[]

IMPORTANT: Click the *Publish Branch* button to push the new changes to the code repository.

Once the changes are pushed to the code repository, a Red Hat OpenShift Pipelines task is triggered to automatically build the application and bundle it into a container.

TIP: We are using a container as it is the best way to package an application and all of its dependencies into a single unit. 
This makes it simple to distribute to physical or virtual hardware for testing.

To check the progress of the build, see https://backstage-backstage.{openshift_cluster_ingress_domain}/catalog/default/component/{user}-jumpstarter-lab/ci[here,window=_blank]

NOTE: The container image is pushed to the container registry, Red Hat Quay, and also deployed to the OpenShift cluster, for further testing.


[#merge]
== Create a Merge Request

Now that we have the container image, we can start the process of building the RHIVOS image. The build is triggered by a `merge request`, so we need to create one.

You can get to the GitLab interface by clicking on *View source* on the Red Hat Developer Hub dashboard.

image::act3/01-go-to-gitlab.png[]

IMPORTANT: In GitLab, select the `develop` branch and click on the *Merge Request* button,

image::act3/02-create-mr.png[]

NOTE: Merge requests are a way to propose changes to the codebase. They allow for code review, discussion, and **automated testing** before merging changes into the main branch.

image::act3/03-create-mr-2.png[]

IMPORTANT: To create a merge request, click on the *Create Merge Request* button

By creating a merge request, a different pipeline will be triggered, in this case, the one defined in `.tekton/tasks/pr-build-test.yaml`.

image::act3/04-mr-pipeline-running.png[]

TIP: If you go to the CI tab in the Red Hat Developer Hub dashboard, you can see the pipelines running.

image::act3/05-pipeline-details-backstage.png[]


https://backstage-backstage.{openshift_cluster_ingress_domain}/catalog/default/component/{user}-jumpstarter-lab/ci[window=_blank]

image::act3/06-pipeline-details.png[]

Looking in detail, this pipeline performs the following steps:

- `fetch-repository`: Clones the repository and checks out the *develop* branch from our merge request.
- `prepare-jumpstarter-config`: Prepares the Jumpstarter configuration files for authenticating to the Jumpstarter service.
- `build-container`: Builds and pushes the container image for our application using the *Containerfile* located in the *src* directory.
- `tag-container`: Tags the container image as *latest*.
- `prepare-build`: Validates the RHIVOS automotime image builder definition in *.aib-ci.yaml* and prepares the build environment.
- `automotive-image-builder`: Builds the RHIVOS image using the *automotive-image-builder tool*, which is a part of the Red Hat In-Vehicle OS (RHIVOS) project.
- `create-jumpstarter-lease`: Requests and waits for a Jumpstarter exporter lease, the leased device (or virtual device) will be used for testing in the following tasks.
- `flash-with-jumpstarter`: Flashes the RHIVOS image to the leased device using Jumpstarter.
- `test-with-jumpstarter`: Runs the defined test cases in the *tests* directory of our project on the flashed device.
- `release`: Finishes the lease and releases the device back to Jumpstarter.
- `s3-upload`: Uploads the built image to an *S3 bucket* for interactive, we will use this on the next.


Once the pipeline is finished, we can see the results reported back to GitLab.

image::act3/07-mr-ready.png[]

[#release]
== Release deployment pipeline

Once the test pipeline has finished, we can start the release pipeline, assuming all the tests have passed.

To trigger the release pipeline, we need to merge the changes on branch `develop` into the main branch. 
Merging the two branches will trigger the release pipeline, which is defined in `.tekton/tasks/pr-build-release.yaml`. 

The release pipeline is similar to the test pipeline, but it focuses on releasing the OS image to hardware:

- It builds the production-ready RHIVOS image optimized for a specific hardware platform (see NOTEs below)
- Uses Jumpstarter to flash the image directly to the physical hardware
- Uses Jumpstarter to run the defined test cases on the physical hardware

NOTE: The release pipeline focuses on hardware testing rather than virtual testing, assuming all validation has been completed in the development pipeline. *An good alternative* is to always use physical devices on merge requests if your lab has sufficient resources,
      this way you can validate the code on hardware before merging it to the main branch.

NOTE: Due to the limited availability of physical hardware in this lab, we will only show this on screen, but the participant pipelines will still test on virtual hardware.

Merging into main can be done by clicking on the *Merge* button in the merge request page:

image::act3/08-merge-mr.png[]

== Next

Now that we've completed the development workflow, we'll explore advanced Jumpstarter capabilities including:

- Configuring Jumpstaterter Exporter for custom hardware
- Recap the development workflow

